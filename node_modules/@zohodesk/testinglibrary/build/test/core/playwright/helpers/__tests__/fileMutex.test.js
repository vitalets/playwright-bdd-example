"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _fileMutex = _interopRequireDefault(require("../../../../../core/playwright/helpers/fileMutex"));
var _path = _interopRequireDefault(require("path"));
var _fs = require("fs");
jest.mock('fs');
describe('FileMutex', () => {
  const directory = '/tmp/locks';
  const lockFileName = 'test-lock';
  const fileDeletionTimeoutConfig = {
    timeout: 1000
  };
  const lockFilePath = _path.default.resolve(directory, lockFileName + '.lock');
  let fileMutex;
  beforeEach(() => {
    jest.clearAllMocks();
    fileMutex = new _fileMutex.default(directory, lockFileName, fileDeletionTimeoutConfig);
  });
  describe('acquire', () => {
    it('should create the lock file if it does not exist', async () => {
      _fs.writeFileSync.mockImplementation(() => {});
      await fileMutex.acquire();
      expect(_fs.writeFileSync).toHaveBeenCalledWith(fileMutex.lockFilePath, 'locked');
    });
    it('should wait for lock file deletion if it exists', async () => {
      _fs.existsSync.mockImplementation(filePath => filePath === fileMutex.lockFilePath);
      _fs.watch.mockImplementation((dir, callback) => {
        setTimeout(() => {
          _fs.existsSync.mockImplementation(() => false);
          callback('rename', fileMutex.lockFileName);
        }, fileDeletionTimeoutConfig);
        return {
          close: jest.fn()
        };
      });
      await fileMutex.acquire();
      expect(_fs.watch).toHaveBeenCalledWith(directory, expect.any(Function));
    });
    it('should reject if watch timeout exceeds', async () => {
      _fs.existsSync.mockImplementation(filePath => filePath === lockFilePath);
      _fs.watch.mockImplementation(() => {
        return {
          close: jest.fn()
        };
      });
      await expect(fileMutex.acquire()).rejects.toThrow('Watch timeout exceeded');
    });
  });
  describe('release', () => {
    it('should delete the lock file if it exists', async () => {
      _fs.existsSync.mockReturnValue(true);
      _fs.unlinkSync.mockImplementation(() => {});
      await fileMutex.release();
      expect(_fs.existsSync).toHaveBeenCalledWith(lockFilePath);
      expect(_fs.unlinkSync).toHaveBeenCalledWith(lockFilePath);
    });
    it('should release lock by deleting lock file', async () => {
      _fs.existsSync.mockReturnValue(true);
      _fs.unlinkSync.mockImplementation(() => {});
      await fileMutex.release();
      expect(_fs.unlinkSync).toHaveBeenCalledWith(lockFilePath);
    });
    it('should not attempt to delete the lock file if it does not exist', async () => {
      _fs.existsSync.mockReturnValue(false);
      await fileMutex.release();
      expect(_fs.existsSync).toHaveBeenCalledWith(lockFilePath);
      expect(_fs.unlinkSync).not.toHaveBeenCalled();
    });
    it('should log an error if deleting the lock file fails', async () => {
      const errorMessage = 'Error deleting lock file';
      _fs.existsSync.mockReturnValue(true);
      _fs.unlinkSync.mockImplementation(() => {
        throw new Error(errorMessage);
      });
      await expect(fileMutex.release()).rejects.toThrow(errorMessage);
    });
  });
});