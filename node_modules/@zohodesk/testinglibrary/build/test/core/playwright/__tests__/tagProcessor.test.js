"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _tagProcessor = _interopRequireDefault(require("../../../../../src/core/playwright/tagProcessor"));
var _logger = require("../../../../utils/logger");
jest.mock('../../../../utils/logger');
describe('TagProcessor', () => {
  const editionOrder = ['edition1', 'edition2', 'edition3', 'edition4'];
  beforeEach(() => {
    jest.clearAllMocks();
  });
  test('should return tagArgs if no edition is provided', () => {
    const tagProcessor = new _tagProcessor.default(editionOrder);
    const userArgs = {
      tags: 'tag1',
      edition: null
    };
    const result = tagProcessor.processTags(userArgs);
    expect(result).toBe('tag1');
  });
  test('should handle a single edition with <= operator', () => {
    const tagProcessor = new _tagProcessor.default(editionOrder);
    const userArgs = {
      tags: 'tag1',
      edition: '<=edition2'
    };
    const result = tagProcessor.processTags(userArgs);
    expect(result).toBe('tag1 and not (@edition_edition3 or @edition_edition4)');
  });
  test('should handle a single edition with >= operator', () => {
    const tagProcessor = new _tagProcessor.default(editionOrder);
    const userArgs = {
      tags: 'tag1',
      edition: '>=edition2'
    };
    const result = tagProcessor.processTags(userArgs);
    expect(result).toBe('tag1 and not (@edition_edition1)');
  });
  test('should handle a single edition with < operator', () => {
    const tagProcessor = new _tagProcessor.default(editionOrder);
    const userArgs = {
      tags: 'tag1',
      edition: '<edition3'
    };
    const result = tagProcessor.processTags(userArgs);
    expect(result).toBe('tag1 and not (@edition_edition3 or @edition_edition4)');
  });
  test('should handle a single edition with > operator', () => {
    const tagProcessor = new _tagProcessor.default(editionOrder);
    const userArgs = {
      tags: 'tag1',
      edition: '>edition1'
    };
    const result = tagProcessor.processTags(userArgs);
    expect(result).toBe('tag1 and not (@edition_edition1)');
  });
  test('should handle a single edition with no operator', () => {
    const tagProcessor = new _tagProcessor.default(editionOrder);
    const userArgs = {
      tags: 'tag1',
      edition: 'edition2'
    };
    const result = tagProcessor.processTags(userArgs);
    expect(result).toBe('tag1 and not (@edition_edition1 or @edition_edition3 or @edition_edition4)');
  });
  test('should log a message if edition is not found', () => {
    const tagProcessor = new _tagProcessor.default(editionOrder);
    const userArgs = {
      tags: 'tag1',
      edition: 'nonexistentEdition'
    };
    const result = tagProcessor.processTags(userArgs);
    expect(result).toBe('tag1');
    expect(_logger.Logger.log).toHaveBeenCalledWith(_logger.Logger.INFO_TYPE, expect.stringContaining('No matching editions for nonexistentEdition found.'));
  });
  test('should handle multiple editions', () => {
    const tagProcessor = new _tagProcessor.default(editionOrder);
    const userArgs = {
      tags: 'tag1',
      edition: 'edition1,edition3'
    };
    const result = tagProcessor.processTags(userArgs);
    expect(result).toBe('tag1 and not (@edition_edition2 or @edition_edition4)');
  });
  test('should build tags correctly when tags are empty', () => {
    const tagProcessor = new _tagProcessor.default(editionOrder);
    const userArgs = {
      tags: '',
      edition: 'edition1'
    };
    const result = tagProcessor.processTags(userArgs);
    expect(result).toBe('not (@edition_edition2 or @edition_edition3 or @edition_edition4)');
  });
});