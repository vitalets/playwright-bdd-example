"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _validateFeature = _interopRequireDefault(require("../../../../core/playwright/validateFeature"));
var _parseUserArgs = _interopRequireDefault(require("../../../../core/playwright/helpers/parseUserArgs"));
var _readConfigFile = require("../../../../core/playwright/readConfigFile");
var _tagProcessor = _interopRequireDefault(require("../../../../core/playwright/tagProcessor"));
var _testRunner = require("../../../../core/playwright/test-runner");
var _logger = require("../../../../utils/logger");
jest.mock('../../../../core/playwright/helpers/parseUserArgs', () => ({
  __esModule: true,
  default: jest.fn()
}));
jest.mock('../../../../core/playwright/readConfigFile');
jest.mock('../../../../core/playwright/tagProcessor');
jest.mock('../../../../core/playwright/test-runner');
jest.mock('../../../../utils/logger', () => ({
  __esModule: true,
  Logger: {
    log: jest.fn(),
    SUCCESS_TYPE: 'success',
    FAILURE_TYPE: 'failure'
  }
}));
describe('validateFeatureFiles', () => {
  let tagProcessorInstance;
  beforeEach(() => {
    jest.clearAllMocks();
    tagProcessorInstance = {
      processTags: jest.fn()
    };
    _tagProcessor.default.mockImplementation(() => tagProcessorInstance);
  });
  test('runPreprocessing with correct arguments and log success', async () => {
    const mockUserArgs = {
      mode: 'dev'
    };
    _parseUserArgs.default.mockReturnValue(mockUserArgs);
    const mockConfig = {
      editionOrder: ["beta", "enterprice"]
    };
    _readConfigFile.generateConfigFromFile.mockReturnValue(mockConfig);
    _readConfigFile.isUserConfigFileAvailable.mockReturnValue(true);
    const mockTagArgs = ['@beta_admin'];
    tagProcessorInstance.processTags.mockReturnValue(mockTagArgs);
    _testRunner.runPreprocessing.mockResolvedValueOnce();
    await (0, _validateFeature.default)();
    expect(_parseUserArgs.default).toHaveBeenCalled();
    expect(_readConfigFile.generateConfigFromFile).toHaveBeenCalled();
    expect(_readConfigFile.isUserConfigFileAvailable).toHaveBeenCalled();
    expect(tagProcessorInstance.processTags).toHaveBeenCalledWith(mockUserArgs);
    expect(_testRunner.runPreprocessing).toHaveBeenCalledWith(mockTagArgs, expect.stringContaining('config-creator.js'));
    expect(_logger.Logger.log).toHaveBeenCalledWith(_logger.Logger.SUCCESS_TYPE, 'Feature files validated successfully.');
  });
  test('runPreprocessing with playwright conf', async () => {
    const mockTagArgs = ['@beta_admin'];
    tagProcessorInstance.processTags.mockReturnValue(mockTagArgs);
    _readConfigFile.isUserConfigFileAvailable.mockReturnValue(false);
    _testRunner.runPreprocessing.mockResolvedValueOnce();
    await (0, _validateFeature.default)();
    expect(_testRunner.runPreprocessing).toHaveBeenCalledWith(mockTagArgs, expect.stringContaining('playwright.config.js'));
  });
  test('error when runPreprocessing fails', async () => {
    const mockError = new Error('Test error');
    _testRunner.runPreprocessing.mockRejectedValueOnce(mockError);
    await await (0, _validateFeature.default)();
    expect(_logger.Logger.log).toHaveBeenCalledWith(_logger.Logger.FAILURE_TYPE, `Error while validating the feature files - ${mockError}`);
  });
});