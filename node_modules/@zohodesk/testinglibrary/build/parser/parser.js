"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateSpecCodeForFeatureFile = generateSpecCodeForFeatureFile;
exports.parseFeature = parseFeature;
exports.specFileGenerator = specFileGenerator;
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _logger = require("../utils/logger");
var _cliArgsToObject = require("../utils/cliArgsToObject");
var _fileUtils = require("../utils/fileUtils");
var _readConfigFile = require("../core/playwright/readConfigFile");
var _stepDefinitionsFormatter = require("../utils/stepDefinitionsFormatter");
function parseFeature(featureContent) {
  const lines = featureContent.split('\n');
  let currentFeature = null;
  let currentScenario = null;
  let insideExampleTable = false;
  let isHeaderRow = false; // To skip the first row in the Examples section

  const parsedData = {
    feature: null,
    scenarios: []
  };
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (trimmedLine.startsWith('Feature:')) {
      if (currentFeature) {
        parsedData.feature = currentFeature;
      }
      currentFeature = {
        name: trimmedLine.replace('Feature:', '').trim(),
        scenarios: []
      };
    } else if (trimmedLine.startsWith('Scenario:')) {
      if (currentScenario) {
        currentFeature.scenarios.push(currentScenario);
      }
      currentScenario = {
        name: trimmedLine.replace('Scenario:', '').trim(),
        steps: [],
        examples: []
      };
      insideExampleTable = false;
    } else if (trimmedLine.startsWith('Examples:')) {
      insideExampleTable = true;
      isHeaderRow = true; // Reset to true for each Examples section
      const headerLine = lines[lines.indexOf(line) + 1].trim();
      const tableHeader = headerLine.split('|').filter(cell => cell !== "").map(cell => cell.trim());
      currentScenario.examples.push({
        tableHeader,
        tableRows: []
      });
    } else if (insideExampleTable && trimmedLine.startsWith('|')) {
      if (!isHeaderRow) {
        const exampleRow = trimmedLine.split('|').filter(cell => cell !== "").map(cell => cell.trim());
        if (exampleRow.length === currentScenario.examples[0].tableHeader.length) {
          currentScenario.examples[0].tableRows.push(exampleRow);
        }
      } else {
        isHeaderRow = false;
      }
    } else if (trimmedLine.startsWith('Given') || trimmedLine.startsWith('When') || trimmedLine.startsWith('Then') || trimmedLine.startsWith('And')) {
      currentScenario.steps.push(trimmedLine);
    }
  }
  if (currentFeature) {
    parsedData.feature = currentFeature;
  }
  if (currentScenario) {
    currentFeature.scenarios.push(currentScenario);
  }
  return parsedData;
}
function generateSpecFileContent({
  feature
}) {
  let specContent = 'import { test } from "@zohodesk/testinglibrary";\n\n';
  if (feature && feature.scenarios && feature.scenarios.length > 0) {
    //specContent += `test.describe('${feature.name}', () => {\n`;
    specContent += `// Feature: ${feature.name} \n`;
    feature.scenarios.forEach(scenario => {
      // specContent += '	/*\n'
      // if (scenario.steps && scenario.steps.length > 0) {
      // 	scenario.steps.forEach(step => {
      // 		specContent += `		** ${step}\n`
      // 	})

      // }
      // specContent += '	*/\n'
      specContent += `test('${scenario.name}', async({ Given, When, Then, And }) => {\n`;
      //specContent += `		// Your implementation here\n`;
      if (scenario.steps && scenario.steps.length > 0) {
        scenario.steps.forEach(step => {
          let foundDelimiter = (0, _stepDefinitionsFormatter.findDelimiterFromStep)(step);
          if (foundDelimiter) {
            // Wrap the part of the string after the delimiter with a function call
            let splitResult = step.split(foundDelimiter);
            let wrappedString = `	await ${foundDelimiter}(${JSON.stringify(splitResult[1].trim())}, () => {\n		//${foundDelimiter} Implementation will be here\n	})();\n\n`;
            specContent += wrappedString;
          }
        });
      }
      specContent += `});\n\n`;
    });
    //specContent += `});\n\n`;
  }
  return specContent;
}
function updateExistingSpecFile({
  feature
}, specFile) {
  if (feature && feature.scenarios && feature.scenarios.length > 0) {
    let specFileCode = _fs.default.readFileSync(specFile, 'utf8');
    feature.scenarios.forEach(({
      name,
      steps
    }) => {
      const scenarioComment = `/*\n${steps.map(step => `    ** ${step}`).join('\n')}\n	*/`;
      const testNamePattern = new RegExp(`test\\('${name}',`, 'g');
      const testNameMatches = specFileCode.match(testNamePattern);
      if (testNameMatches) {
        testNameMatches.forEach(match => {
          const startIdx = specFileCode.indexOf(match);

          // Find the index of the comment above the test block
          const commentStartIdx = specFileCode.lastIndexOf('/*', startIdx);
          const commentEndIdx = specFileCode.lastIndexOf('*/', startIdx);
          if (commentStartIdx >= 0 && commentEndIdx > commentStartIdx) {
            // Remove the old comment above the test block
            specFileCode = specFileCode.slice(0, commentStartIdx) + scenarioComment + specFileCode.slice(commentEndIdx + 2);
          }
        });
      } else {
        // Create a new test block if the test name is not found
        const newTestBlock = `	${scenarioComment}\n	test('${name}', () => {\n    // Your implementation here\n	});\n\n\n`;
        // Locate the closest describe block for the new test
        const lastDescribeEndIdx = specFileCode.lastIndexOf('});');
        specFileCode = specFileCode.slice(0, lastDescribeEndIdx) + newTestBlock + specFileCode.slice(lastDescribeEndIdx);
      }
    });

    // Save the updated code back to the spec file
    _fs.default.writeFileSync(specFile, specFileCode, 'utf8');
    _logger.Logger.log(_logger.Logger.SUCCESS_TYPE, 'Spec file updated successfully');
  }
}
function specFileGenerator(filePath, isUpdate) {
  _logger.Logger.log(_logger.Logger.INFO_TYPE, `Generating spec file using file ${filePath}`);
  // Read the Gherkin feature file
  let {
    featureFilesFolder = 'feature-files',
    stepDefinitionsFolder = 'steps'
  } = (0, _readConfigFile.generateConfigFromFile)();
  _fs.default.readFile(filePath, 'utf8', (err, data) => {
    if (err) {
      _logger.Logger.log(_logger.Logger.FAILURE_TYPE, `Error reading the file: ${err}`);
    } else {
      // Parse the feature file content and get the JSON-like object
      const parsedFeature = parseFeature(data);
      let specFilePath = filePath.replace(/\.feature$/, '.spec.js');
      if (filePath.includes(`${featureFilesFolder}`)) {
        specFilePath = specFilePath.replace(`/${featureFilesFolder}/`, `/${stepDefinitionsFolder}/`);
      } else {
        specFilePath = specFilePath.replace('./', `${stepDefinitionsFolder}`);
      }
      if ((0, _fileUtils.checkIfFileExists)(specFilePath)) {
        if (isUpdate) {
          updateExistingSpecFile(parsedFeature, specFilePath);
        } else {
          _logger.Logger.log(_logger.Logger.FAILURE_TYPE, 'File Already exists. Make sure to either delete or pass --update option true');
        }
        return;
      }

      // Output the JSON-like object
      //console.log(JSON.stringify(parsedFeature, null, 2));
      //fs.writeFileSync('./sample.json', JSON.stringify(parsedFeature, null, 2));
      const specFileContent = generateSpecFileContent(parsedFeature);

      // Write the spec file content to a new file
      try {
        (0, _fileUtils.writeFileContents)(specFilePath, specFileContent);
        _logger.Logger.log(_logger.Logger.SUCCESS_TYPE, 'Spec file generated successfully.');
      } catch (writeErr) {
        _logger.Logger.log(_logger.Logger.FAILURE_TYPE, `Error writing the spec file: ${writeErr}`);
      }
    }
  });
}
function generateSpecCodeForFeatureFile(options) {
  let cliObj = (0, _cliArgsToObject.cliArgsToObject)(options);
  let {
    featureFile: featureFilePath = null,
    update = false
  } = cliObj;
  if (featureFilePath) {
    specFileGenerator(_path.default.join(process.cwd(), './', featureFilePath), update);
  } else {
    _logger.Logger.log(_logger.Logger.FAILURE_TYPE, 'Need option --featureFile to run this command');
  }
}