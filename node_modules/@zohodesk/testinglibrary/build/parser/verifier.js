"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _path = _interopRequireDefault(require("path"));
var _fastGlob = _interopRequireDefault(require("fast-glob"));
var _parser = require("./parser");
var _logger = require("../utils/logger");
var _fileUtils = require("../utils/fileUtils");
var _readConfigFile = require("../core/playwright/readConfigFile");
var _stepDefinitionsFormatter = require("../utils/stepDefinitionsFormatter");
// Specify the directory where you want to search for .feature and .spec.js files
const directoryPath = './uat';

// Use glob to match .feature files in the directory
const featurePattern = _path.default.join(process.cwd(), directoryPath, '**/*.feature');

// function onSpecFileNotFound() { }

function verifyIfMultipleStepsExists(steps) {
  let isMultipleStepsFound = false;
  Object.keys(steps).map(step => {
    if (steps[step].length > 1) {
      _logger.Logger.log(_logger.Logger.INFO_TYPE, `Multiple Steps Found for ${step} \n`);
      steps[step].forEach(fileName => {
        _logger.Logger.log(_logger.Logger.INFO_TYPE, `Files: \n ${fileName} \n`);
      });
      // multipleSteps.push({ step: steps[step] });
      isMultipleStepsFound = true;
    }
  });
  return isMultipleStepsFound;
}
function extractExamplesToSeperateFile(examples, scenarioIndex, filePath, featureName) {
  let exampleFileContent = `export const ${featureName.toUpperCase()}_SCENARIO_${scenarioIndex} = ${JSON.stringify(examples, null, 2)};\r\n`;
  const cleanedData = exampleFileContent.replace(/\r\n/g, '\n');
  try {
    (0, _fileUtils.writeFileContents)(filePath, cleanedData, {
      flag: 'a'
    });
  } catch (err) {
    _logger.Logger.error(err);
    throw new Error(`Error appending or creating the test data file: ${filePath}`);
  }
}
function verifyFeatureFileWithSpecFile() {
  try {
    let errorCount = 0;
    let allStepsFound = {};
    let {
      featureFilesFolder = 'feature-files',
      stepDefinitionsFolder = 'steps'
    } = (0, _readConfigFile.generateConfigFromFile)();
    const featureFiles = _fastGlob.default.globSync([featurePattern], {
      dot: true
    });
    featureFiles.forEach(featureFile => {
      // Construct the corresponding .spec.js filename
      const specFile = featureFile.replace(/\.feature$/, '.spec.js').replace(`/${featureFilesFolder}/`, `/${stepDefinitionsFolder}/`);
      let featureFileNameExtract = featureFile.split('/').pop();
      let featurePrefixName = featureFileNameExtract.split('.')[0];
      _logger.Logger.log(_logger.Logger.INFO_TYPE, `parsing feature file ${featureFileNameExtract}...`);
      // Check if the .spec.js file exists

      if ((0, _fileUtils.checkIfFileExists)(specFile)) {
        let featureContents = (0, _fileUtils.readFileContents)(featureFile);
        let specContents = (0, _fileUtils.readFileContents)(specFile);
        //let [featureContents, specContents] = Promise.all([readFileContents(featureFile), readFileContents(specFile)]);
        if (featureContents !== null && specContents !== null) {
          const featureJSON = (0, _parser.parseFeature)(featureContents);
          if (featureJSON && featureJSON.feature) {
            let featureName = featureJSON.feature.name;
            if (specContents.includes(featureName)) {
              const scenarios = featureJSON.feature.scenarios;
              const specLines = specContents.split('\n'); // Split specContents into lines
              let testDataFilePath = featureFile.replace(`/${featureFilesFolder}/`, '/test-data/').replace(/\.feature$/, '.data.js');
              // Examples to test data conversion. we are deleting the existing test data file and create a new file.
              (0, _fileUtils.deleteFile)(testDataFilePath);
              for (let i = 0; i < scenarios.length; i++) {
                let scenario = scenarios[i];
                const scenarioName = scenario.name;
                const scenarioExamples = scenario.examples;
                extractExamplesToSeperateFile(scenarioExamples, i, testDataFilePath, featurePrefixName);

                // spec file check
                if (!specLines.some(line => line.includes(scenarioName))) {
                  errorCount++;
                  _logger.Logger.log(_logger.Logger.FAILURE_TYPE, `Scenario: ${scenarioName} is missing in spec file`);
                }
                for (const step of scenario.steps) {
                  if (!allStepsFound[step]) {
                    allStepsFound[step] = [specFile];
                  } else {
                    allStepsFound[step].push(specFile);
                  }
                  const foundDelimiter = (0, _stepDefinitionsFormatter.findDelimiterFromStep)(step);
                  if (foundDelimiter) {
                    let splitResult = step.split(foundDelimiter);
                    if (!specLines.some(line => line.includes(splitResult[1].trim().replace(/"/g, '\\"')))) {
                      errorCount++;
                      _logger.Logger.log(_logger.Logger.FAILURE_TYPE, `Scenario: ${scenarioName} \n Step: ${step} is missing in the spec file ${specFile}`);
                    }
                  }
                }
              }
            } else {
              errorCount++;
              _logger.Logger.log(_logger.Logger.SUCCESS_TYPE, `Feature Name ${featureName} does not match/exist in ${specFile}`);
            }
          }
        } else {
          errorCount++;
          _logger.Logger.log(_logger.Logger.FAILURE_TYPE, `Error while reading feature file ${featureFile} or spec file ${specFile}`);
        }
      } else {
        errorCount++;
        _logger.Logger.log(_logger.Logger.FAILURE_TYPE, `No corresponding .spec.js file found for ${featureFile}`);
      }
    });
    // Multiple steps found warning
    verifyIfMultipleStepsExists(allStepsFound);
    if (errorCount > 0) {
      _logger.Logger.log(_logger.Logger.FAILURE_TYPE, `Total Number of Errors found - ${errorCount}`);
      throw new Error('Error while parsing feature files. Please fix the above issues before running test cases');
    }
  } catch (err) {
    _logger.Logger.log(_logger.Logger.FAILURE_TYPE, err);
    process.exit(1);
  }
}
verifyFeatureFileWithSpecFile();