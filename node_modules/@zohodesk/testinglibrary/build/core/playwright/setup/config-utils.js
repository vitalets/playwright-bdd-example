"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBrowsersList = getBrowsersList;
exports.getModulePathForFeatureFiles = getModulePathForFeatureFiles;
exports.getProjects = getProjects;
exports.getTestDir = getTestDir;
var _test = require("@playwright/test");
var _path = _interopRequireDefault(require("path"));
var _readConfigFile = require("../readConfigFile");
var _playwrightBdd = require("playwright-bdd");
var _logger = require("../../../utils/logger");
var _browserTypes = require("../constants/browserTypes");
var _fileUtils = require("../../../utils/fileUtils");
/**
 ** Playwright project configuration
 * @returns {import('@playwright/test').Project}
 */
function getBrowserConfig({
  browserName,
  isAuthMode,
  authFilePath,
  expectTimeout,
  testTimeout,
  viewport
}) {
  const browser = browserName.toLowerCase();
  const commonConfig = {
    viewport,
    storageState: isAuthMode ? (0, _readConfigFile.getAuthFilePath)(_path.default.resolve(process.cwd(), authFilePath)) : {}
  };
  const dependencies = isAuthMode ? ['setup'] : [];
  if (browser === 'chrome') {
    return {
      name: _browserTypes.BROWSER_PROJECT_MAPPING.CHROME,
      use: {
        ..._test.devices['Desktop Chrome'],
        ...commonConfig
      },
      dependencies,
      timeout: testTimeout,
      expect: {
        timeout: expectTimeout
      }
    };
  } else if (browser === 'edge') {
    return {
      name: _browserTypes.BROWSER_PROJECT_MAPPING.EDGE,
      timeout: testTimeout,
      expect: {
        timeout: expectTimeout
      },
      use: {
        ..._test.devices['Desktop Chrome'],
        channel: 'msedge',
        ...commonConfig
      },
      dependencies
    };
  } else if (browser === 'firefox') {
    return {
      name: _browserTypes.BROWSER_PROJECT_MAPPING.FIREFOX,
      timeout: 2 * testTimeout,
      expect: {
        timeout: 2 * expectTimeout
      },
      use: {
        ..._test.devices['Desktop Firefox'],
        ...commonConfig
      },
      dependencies
    };
  } else if (browser === 'safari') {
    return {
      name: _browserTypes.BROWSER_PROJECT_MAPPING.SAFARI,
      timeout: 4 * testTimeout,
      expect: {
        timeout: 4 * expectTimeout
      },
      use: {
        ..._test.devices['Desktop Safari'],
        ...commonConfig
      },
      dependencies
    };
  } else {
    return false;
  }
}

/**
 *
 * @param {*} param0
 * @returns {import('@playwright/test').Project[]}
 */
function getProjects({
  browsers,
  isAuthMode,
  authFilePath,
  expectTimeout,
  testTimeout,
  viewport
}) {
  return browsers.map(browserName => getBrowserConfig({
    browserName,
    isAuthMode,
    authFilePath,
    expectTimeout,
    testTimeout,
    viewport
  })).filter(Boolean);
}
function getBrowsersList(browserFromArgs) {
  if (browserFromArgs) {
    if (typeof browserFromArgs === 'string') {
      let listOfbrowsers = browserFromArgs.split(',').map(browser => browser.trim().toLowerCase());
      _logger.Logger.log(_logger.Logger.INFO_TYPE, 'Using browsers from command line args');
      return listOfbrowsers;
    }
  }
  return [];
}
function getPathsForFeatureFiles(cwd) {
  if (process.env.isRerunFailedCases) {
    let {
      reportPath
    } = (0, _readConfigFile.generateConfigFromFile)();
    let filePathFromArgs = process.env.filePath;
    let filePath = filePathFromArgs ? filePathFromArgs : reportPath;
    const testSummary = (0, _fileUtils.readFileContents)(filePath);
    if (testSummary !== null) {
      const {
        failed = []
      } = JSON.parse(testSummary);
      const casesToRun = failed.map(filePath => _path.default.join(cwd, 'uat', filePath.replace(/\.spec\.js$|\.js$/, '')));
      return casesToRun;
    } else {
      _logger.Logger.log(_logger.Logger.INFO_TYPE, `Unable to read test summary from the ${reportPath}. Verify If File Exists in the path`);
      _logger.Logger.log(_logger.Logger.INFO_TYPE, 'Going to run all test cases');
    }
  } else if (process.env.modules !== 'undefined' && process.env.modules.length > 0) {
    let modules = process.env.modules;
    let moduleList = modules.split(',');
    return getModulePathForFeatureFiles(moduleList);
  }
  return [_path.default.join(cwd, 'uat', '**', '*.feature')];
}
function getModulePathForFeatureFiles(moduleList) {
  let validModuleList = [];
  moduleList.forEach(moduleName => {
    let modulePath = _path.default.join(process.cwd(), 'uat', 'modules', '**', `${moduleName}`);
    if ((0, _fileUtils.checkIfFolderExistsWithPattern)(modulePath)) {
      validModuleList.push(_path.default.join(modulePath, '**', '*.feature'));
    } else {
      _logger.Logger.log(_logger.Logger.FAILURE_TYPE, `Module ${moduleName} does not exist, Please check the module name`);
      validModuleList = [];
      return validModuleList;
    }
  });
  return validModuleList;
}
function getTestDir(bddMode, cwd, {
  stepDefinitionsFolder
}) {
  console.log('cwd - ', cwd);
  console.log('feature file path - ', getPathsForFeatureFiles(cwd));
  return bddMode ? (0, _playwrightBdd.defineBddConfig)({
    features: getPathsForFeatureFiles(cwd),
    steps: [_path.default.join(cwd, '/features/steps/', '*.ts'), _path.default.join(cwd, '/node_modules/@zohodesk/testinglibrary/build/common/', '**', 'uat', '**', '*.spec.js'), require.resolve('../fixtures.js')],
    importTestFrom: require.resolve('../fixtures.js'),
    featuresRoot: _path.default.join(cwd, 'uat'),
    outputDir: _path.default.join(cwd, 'uat', '.features-gen'),
    disableWarnings: {
      importTestFrom: true
    },
    publish: true
  }) : _path.default.join(cwd, 'uat');
}