"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _readConfigFile = require("../readConfigFile");
var _rootPath = require("../../../utils/rootPath");
var _path = _interopRequireDefault(require("path"));
var _logger = require("../../../utils/logger");
var _child_process = require("child_process");
var _RunnerHelper = _interopRequireDefault(require("./RunnerHelper"));
var _Runner = _interopRequireDefault(require("./Runner"));
class SpawnRunner extends _Runner.default {
  constructor(runnerObj) {
    super(runnerObj);
    this.runnerObj = runnerObj;
  }
  run() {
    const {
      config
    } = this.runnerObj;
    let promises = [];
    const {
      bddMode
    } = config.getAll();
    if (bddMode) {
      promises.push(this.runPreprocessing());
    }
    Promise.all(promises).then(() => this.runPlaywright()).catch(err => {
      _logger.Logger.error(err);
      process.exit();
    });
  }
  runPreprocessing() {
    const {
      tagArgs
    } = this.runnerObj;
    const configPath = (0, _readConfigFile.isUserConfigFileAvailable)() ? _path.default.resolve(__dirname, '../', 'setup', 'config-creator.js') : _path.default.resolve(__dirname, '../', '../', '../', '../', 'playwrightConfig.js');
    const beforeCommand = 'node';
    const bddGenPath = _path.default.resolve((0, _rootPath.getExecutableBinaryPath)('bddgen'));
    const beforeArgs = [bddGenPath, '-c', require.resolve(configPath)];
    if (tagArgs) {
      beforeArgs.push('--tags');
      beforeArgs.push(tagArgs);
    }
    return new Promise((resolve, reject) => {
      const childProcessForPreprocessing = (0, _child_process.spawn)(beforeCommand, beforeArgs, {
        stdio: 'inherit',
        env: {
          ...process.env
        }
      });
      childProcessForPreprocessing.on('error', data => {
        _logger.Logger.log(_logger.Logger.FAILURE_TYPE, data);
        reject(data);
      });
      childProcessForPreprocessing.on('exit', code => {
        if (code === 0) {
          _logger.Logger.log(_logger.Logger.SUCCESS_TYPE, 'Feature Files Processed Successfully');
          resolve();
        } else {
          reject(`BddGen exited with code ${code}`);
        }
      });
    });
  }
  runPlaywright() {
    const {
      tagArgs,
      config,
      userArgs
    } = this.runnerObj;
    const {
      debug,
      bddMode = false,
      headless = false
    } = config.getAll();
    const playwrightArgs = _RunnerHelper.default.getPlaywrightArgs(userArgs, debug, bddMode, tagArgs, headless);
    const playwrightPath = _path.default.resolve((0, _rootPath.getExecutableBinaryPath)('playwright'));
    const command = playwrightPath;
    const configPath = (0, _readConfigFile.isUserConfigFileAvailable)() ? _path.default.resolve(__dirname, '../', 'setup', 'config-creator.js') : _path.default.resolve('../', '../', '../', '../', 'playwrightConfig.js');
    const args = ['test', '--config', require.resolve(configPath)].concat(playwrightArgs);
    return new Promise((resolve, reject) => {
      const childProcessForRunningPlaywright = (0, _child_process.spawn)(command, args, {
        stdio: 'inherit',
        env: {
          ...process.env
        }
      });
      childProcessForRunningPlaywright.on('error', error => {
        _logger.Logger.log(_logger.Logger.FAILURE_TYPE, error);
      });
      childProcessForRunningPlaywright.on('exit', (code, signal) => {
        if (code !== 0) {
          reject(`Child Process Exited with Code ${code} and Signal ${signal}`);
        } else {
          _logger.Logger.log(_logger.Logger.SUCCESS_TYPE, 'Test Ran Successfully');
          resolve();
        }
      });
      process.on('exit', () => {
        childProcessForRunningPlaywright.kill();
        reject('Terminating Playwright Process...');
      });
      process.on('SIGINT', () => {
        childProcessForRunningPlaywright.kill();
        reject('Cleaning up...');
      });
    });
  }
}
module.exports = SpawnRunner;