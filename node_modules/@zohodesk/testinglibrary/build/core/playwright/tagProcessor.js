"use strict";

var _logger = require("../../utils/logger");
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _TagProcessor_brand = /*#__PURE__*/new WeakSet();
class TagProcessor {
  constructor(editionOrder) {
    _classPrivateMethodInitSpec(this, _TagProcessor_brand);
    this.editionOrder = editionOrder;
  }
  processTags(userArgs) {
    const tagArgs = userArgs['tags'] || '';
    const edition = userArgs['edition'] || null;
    if (!edition) return tagArgs;
    const editionsArray = edition.split(',');
    const editionTags = editionsArray.length === 1 ? _assertClassBrand(_TagProcessor_brand, this, _processSingleEdition).call(this, editionsArray[0], tagArgs) : _assertClassBrand(_TagProcessor_brand, this, _processMultipleEditions).call(this, editionsArray, tagArgs);
    return editionTags;
  }
}
function _buildTagsString(tags, editionTags) {
  return tags && tags !== '' ? `${tags} and not (${editionTags})` : `not (${editionTags})`;
}
function _parseEdition(edition) {
  if (edition.startsWith('<=')) return ['<=', edition.slice(2)];
  if (edition.startsWith('>=')) return ['>=', edition.slice(2)];
  if (edition.startsWith('<')) return ['<', edition.slice(1)];
  if (edition.startsWith('>')) return ['>', edition.slice(1)];
  return [null, edition];
}
function _processSingleEdition(selectedEdition, tagArgs) {
  const editionArgs = _assertClassBrand(_TagProcessor_brand, this, _getEditionArgs).call(this, selectedEdition);
  if (editionArgs && editionArgs.length > 0) {
    const editionTags = _assertClassBrand(_TagProcessor_brand, this, _buildEditionTags).call(this, editionArgs, 'or');
    return _assertClassBrand(_TagProcessor_brand, this, _buildTagsString).call(this, tagArgs, editionTags);
  }
  _logger.Logger.log(_logger.Logger.INFO_TYPE, `No matching editions for ${selectedEdition} found. Running with default edition`);
  return tagArgs;
}
function _processMultipleEditions(editionsArray, tagArgs) {
  const filteredEditions = this.editionOrder.filter(edition => !editionsArray.includes(edition));
  const editionTags = _assertClassBrand(_TagProcessor_brand, this, _buildEditionTags).call(this, filteredEditions, 'or');
  return _assertClassBrand(_TagProcessor_brand, this, _buildTagsString).call(this, tagArgs, editionTags);
}
function _getEditionArgs(selectedEdition) {
  const [operator, editionValue] = _assertClassBrand(_TagProcessor_brand, this, _parseEdition).call(this, selectedEdition.toLowerCase());
  const index = this.editionOrder.findIndex(edition => edition.toLowerCase() === editionValue);
  if (index === -1) {
    _logger.Logger.log(_logger.Logger.INFO_TYPE, `No matching editions for ${selectedEdition} found. Running with default edition`);
    return [];
  }
  switch (operator) {
    case '<=':
      return this.editionOrder.slice(index + 1);
    case '>=':
      return this.editionOrder.slice(0, index);
    case '<':
      return this.editionOrder.slice(index);
    case '>':
      return this.editionOrder.slice(0, index + 1);
    default:
      return this.editionOrder.filter((_, i) => i !== index);
  }
}
function _buildEditionTags(editionArgs, operator = 'or') {
  return editionArgs.map(edition => `@edition_${edition}`).join(` ${operator} `);
}
module.exports = TagProcessor;