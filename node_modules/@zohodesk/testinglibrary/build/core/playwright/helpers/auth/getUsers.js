"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultActor = getDefaultActor;
exports.getDefaultActorConf = getDefaultActorConf;
exports.getListOfActors = getListOfActors;
exports.getRunMode = getRunMode;
exports.getUserForSelectedEditionAndProfile = getUserForSelectedEditionAndProfile;
exports.isCI = isCI;
exports.isDevelopmentSetup = isDevelopmentSetup;
var _path = _interopRequireDefault(require("path"));
var _fs = require("fs");
var _readConfigFile = require("../../readConfigFile");
/* eslint-disable global-require */
function getRunMode() {
  let {
    mode
  } = process.env;
  return mode || 'dev';
}
function isCI() {
  const mode = getRunMode();
  return mode === 'CI' || mode === 'ci';
}
function isDevelopmentSetup() {
  const mode = getRunMode();
  return mode === 'DEV' || mode === 'dev';
}
function getDefaultActorConf() {
  const {
    uatDirectory
  } = (0, _readConfigFile.generateConfigFromFile)();
  const modeSettingsFile = `conf/${getRunMode()}/settings.json`;
  const filePath = _path.default.join(uatDirectory, modeSettingsFile);
  try {
    if (!(0, _fs.existsSync)(filePath)) {
      const defaultSettingsFile = _path.default.join(uatDirectory, `conf/default/settings.json`);
      return require(defaultSettingsFile);
    }
    return require(filePath);
  } catch (error) {
    throw new Error(`${defaultSettingFile} ${filePath} both files are missing.`);
  }
}
function getDefaultActor() {
  const {
    edition,
    profile
  } = getDefaultActorConf();
  return getUserForSelectedEditionAndProfile(edition, profile);
}
function getListOfActors(betaFeature) {
  const {
    uatDirectory
  } = (0, _readConfigFile.generateConfigFromFile)();
  const mode = getRunMode();
  let configFile = _path.default.join(uatDirectory, `conf/${mode}/actors/index.js`);
  let betaReference = mode;
  if (!(0, _fs.existsSync)(configFile)) {
    configFile = _path.default.join(uatDirectory, `conf/default/actors/index.js`);
    betaReference = "default";
  }
  if (betaFeature) {
    configFile = _path.default.join(uatDirectory, `conf/${betaReference}/actors/beta/${betaFeature}/index.js`);
    if (!(0, _fs.existsSync)(configFile)) {
      throw new Error(`There is no beta feature configured with the name "${betaFeature}"`);
    }
  }
  try {
    return require(configFile);
  } catch (error) {
    throw new Error(`Error loading actor configuration from ${configFile}`);
  }
}
function getUserForSelectedEditionAndProfile(preferedEdition, preferredProfile, betaFeature, testDataPortal = null) {
  const actorsData = getListOfActors(betaFeature);
  if (!actorsData || !actorsData.editions) {
    throw new Error("The actors data is missing.");
  }
  const {
    editions: userdata
  } = actorsData;
  const defaultConf = getDefaultActorConf();
  const edition = preferedEdition || defaultConf.edition;
  const profile = preferredProfile || defaultConf.profile;
  let selectedProfile = {};

  // TODO: We are returning the first data from array. We need to check the possiblity of having multiple users for same profile and possibly round robin
  // For this we need to get the data from ci environment.

  let testingPortal = null;
  if (!userdata.hasOwnProperty(edition)) {
    throw new Error(`There is no "${edition}" edition configured.`);
  }
  if (testDataPortal !== null) {
    testingPortal = userdata[edition].find(editionData => editionData.orgName === testDataPortal);
    if (!testingPortal) {
      throw new Error(`There is no "${testDataPortal}" portal configured in "${edition}" edition.`);
    }
  } else {
    testingPortal = userdata[edition] ? userdata[edition][0] : {};
  }
  const {
    profiles,
    ...editionData
  } = testingPortal;
  selectedProfile = profiles.find(user => user.profile === profile);
  if (!selectedProfile) {
    throw new Error(`There is no "${profile}" profile configured in "${edition}" edition.`);
  }
  return {
    ...editionData,
    ...selectedProfile
  };
}