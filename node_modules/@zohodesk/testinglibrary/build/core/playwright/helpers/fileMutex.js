"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _path = _interopRequireDefault(require("path"));
var _fs = require("fs");
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _FileMutex_brand = /*#__PURE__*/new WeakSet();
class FileMutex {
  constructor(directory, lockFileName, fileDeletionTimeoutConfig) {
    _classPrivateMethodInitSpec(this, _FileMutex_brand);
    this.directory = directory;
    this.lockFileName = lockFileName + ".lock";
    this.fileDeletionTimeout = fileDeletionTimeoutConfig.timeout;
    this.lockFilePath = _assertClassBrand(_FileMutex_brand, this, _getLockFilePath).call(this);
    _assertClassBrand(_FileMutex_brand, this, _createDirectoryIfNotExist).call(this);
  }
  async acquire() {
    return new Promise((resolve, reject) => {
      if (!(0, _fs.existsSync)(this.lockFilePath)) {
        (0, _fs.writeFileSync)(this.lockFilePath, 'locked');
        console.log(`Lock file created: ${this.lockFilePath}, worker index - ${process.env.TEST_WORKER_INDEX}`);
        return resolve();
      }
      const timeout = setTimeout(() => {
        watcher.close();
        reject(new Error('Watch timeout exceeded'));
      }, this.fileDeletionTimeout);
      const watcher = (0, _fs.watch)(this.directory, (eventType, filename) => {
        try {
          if (eventType === 'rename' && filename === this.lockFileName) {
            clearTimeout(timeout);
            console.log(`Lock file deleted! Proceeding, worker index - ${process.env.TEST_WORKER_INDEX}`);
            watcher.close();
            resolve();
          }
        } catch (err) {
          console.error(`Error watching for lock file deletion: ${err.message}`);
          watcher.close();
        }
      });
    });
  }
  async release() {
    try {
      if ((0, _fs.existsSync)(this.lockFilePath)) {
        (0, _fs.unlinkSync)(this.lockFilePath);
        console.log(`Lock file deleted: ${this.lockFilePath}, worker index - ${process.env.TEST_WORKER_INDEX}`);
      }
    } catch (err) {
      console.error(`Error deleting lock file: ${err.message}, worker index - ${process.env.TEST_WORKER_INDEX}`);
      throw err;
    }
  }
}
function _getLockFilePath() {
  return _path.default.resolve(_path.default.join(this.directory, this.lockFileName));
}
async function _createDirectoryIfNotExist() {
  if (!(0, _fs.existsSync)(this.directory)) {
    (0, _fs.mkdirSync)(this.directory, {
      recursive: true
    });
  }
}
var _default = exports.default = FileMutex;